package offheap.collection

import scala.{ offheap => oh }
import scala.offheap.data

import HashEq._

%{
types = ['Boolean', 'Char', 'Byte', 'Short',
  'Int', 'Long', 'Float', 'Double', 'Object']
}%

% for T in types:

%{
  if T == 'Object':
    T_Arg = 'Long'
    T_Eq = 'Offheap'
  else:
    T_Arg = T
    T_Eq = T
}%

@data class OffheapBufferSeq_${T}(var array: oh.Array[${T_Arg}], var _size: Int) {

  def free(implicit allocator: oh.Allocator) = {
    allocator.free(array.addr)
    allocator.free(addr)
  }

  def apply(index: Int): ${T_Arg} = array(index)

  def append(elem: ${T_Arg})(implicit allocator: oh.Allocator): Unit = {
    val newSize = _size + 1
    growTo(newSize)
    array(_size) = elem
    _size += 1
  }

  def update(index: Int, value: ${T_Arg}): Unit = array(index) = value

  def remove(n: Int): ${T_Arg} = {
    val removed = array(n)
    arraycopy(n + 1, n, _size - n)
    _size -= 1
    removed
  }

  def index(elem: ${T_Arg})(implicit eq: Eq_${T_Eq}): Int = {
    var result = -1
    var i = 0
    while ({
      if (i < _size) {
        if (eq.eqv(array(i), elem)) {
          result = i
          false
        } else {
          i += 1
          true
        }
      } else {
        false
      }
    }) ()
    result
  }

  def insert(index: Int, elem: ${T_Arg})(implicit allocator: oh.Allocator): Unit = {
    val newSize = _size + 1
    growTo(newSize)
    arraycopy(index, index + 1, _size - index)
    array(index) = elem
    _size += 1
  }

  def map_${T}(f: ${T_Arg} => ${T_Arg})(implicit allocator: oh.Allocator): OffheapBufferSeq_${T} = {
    val builder = OffheapSeq_${T}.create(initialSize = array.size)
    var i = 0
    while (i < _size) {
      builder.append(f(array(i)))
      i += 1
    }
    builder
  }

  def flatMap_${T}(f: ${T_Arg} => OffheapBufferSeq_${T})(implicit allocator: oh.Allocator): OffheapBufferSeq_${T} = {
    val builder = OffheapSeq_${T}.create()
    var i = 0
    while (i < _size) {
      val el = array(i)
      val result = f(el)
      val resultSize = result.size
      var j = 0
      while (j < resultSize) {
        builder.append(result(j))
        j += 1
      }
      result.free
      i += 1
    }
    builder
  }

  def filter(f: ${T_Arg} => Boolean)(implicit allocator: oh.Allocator): OffheapBufferSeq_${T} = {
    val result = OffheapSeq_${T}.create()
    var i = 0
    while (i < _size) {
      val el = array(i)
      if (f(el)) result.append(el)
      i += 1
    }
    result
  }

  private def arraycopy(src: Int, dest: Int, len: Int) = oh.Array.copy(array, src, array, dest, len)

  private def shouldGrow(newSize: Int) = newSize > array.size
  private def grow(implicit allocator: oh.Allocator) = {
    val newArray = oh.Array.uninit[${T_Arg}](array.size * 2)
    oh.Array.copy(array, 0, newArray, 0, _size)
    allocator.free(this.array.addr)
    this.array = newArray
  }
  private def growTo(size: Int)(implicit allocator: oh.Allocator) = while (shouldGrow(size)) grow

  private def lowestPowOf2GreaterThan(min: Int) = {
    var result = 1
    while (result <= min) result *= 2
    result
  }

  def empty = _size == 0
  def notEmpty = _size != 0

  def size: Int = _size
  def foreach(f: ${T_Arg} => Unit): Unit = {
    var i = 0
    while (i < _size) {
      f(array(i))
      i += 1
    }
  }
}

object OffheapSeq_${T} {
  def create(initialSize: Int = 16)(implicit allocator: oh.Allocator): OffheapBufferSeq_${T} =
    OffheapBufferSeq_${T}(oh.Array.uninit[${T_Arg}](initialSize), 0)
}

% end
