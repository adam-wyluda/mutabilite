package offheap.collection

import scala.{ offheap => oh }
import scala.offheap.data

import HashEq._

%{
types = ['Boolean', 'Char', 'Byte', 'Short',
'Int', 'Long', 'Float', 'Double', 'Object']
}%

% for T in types:
% if T != 'Object':
@data class OffheapOpt_${T}(value: ${T}) extends Opt_${T} {
  def empty = isEmpty
  def size = if (nonEmpty) 1 else 0
  def foreach(f: ${T} => Unit) = if (nonEmpty) f(value) else ()
}
% end
% end

@data class OffheapOpt_Object(value: Long) extends Opt_Long {
  def empty = isEmpty
  def size = if (nonEmpty) 1 else 0
  def foreach(f: Long => Unit) = if (nonEmpty) f(value) else ()
}

% for K in types:
% for V in types:

%{
  if K == 'Object':
    K_Arg = 'Long'
    K_Hash = 'Offheap'
  else:
    K_Arg = K
    K_Hash = K

  if V == 'Object':
    V_Arg = 'Long'
    V_Hash = 'Offheap'
  else:
    V_Arg = V
    V_Hash = K
}%

@data class OffheapHashMap_${K}_${V}
(
  var hashes: oh.Array[Int],
  var _keys: oh.Array[${K_Arg}],
  var _values: oh.Array[${V_Arg}],
  var _size: Int,
  var capacity: Int,
  var mask: Int
) {

  def apply(key: ${K_Arg})
      (implicit hashK: Hash_${K_Hash}, allocator: scala.offheap.Allocator): OffheapOpt_${V_Arg} = {
    val index = indexOf(key)
    if (index == -1) {
      OffheapOpt_${V_Arg}.empty
    } else {
      OffheapOpt_${V_Arg}(_values(index))
    }
  }

  private[this] def indexOf(key: ${K_Arg})(implicit hashK: Hash_${K_Hash}): Int = {
    var hash = calcHashCode(key)
    var pos = hash
    var dis = 0
    var result = -1
    while ({
      val nextHash = hashes(pos)
      if (!isInit(nextHash)) {
        val nextDis = (capacity + pos - nextHash) & mask
        if (nextDis >= dis) {
          if (hash == nextHash && hashK.eqv(_keys(pos), key)) {
            result = pos
            false
          } else {
            dis += 1
            pos = (pos + 1) & mask
            true
          }
        } else {
          false
        }
      } else {
        false
      }
    }) ()
    result
  }

  def put(key: ${K_Arg}, value: ${V_Arg})
      (implicit hashK: Hash_${K_Hash}, allocator: scala.offheap.Allocator): OffheapOpt_${V_Arg} = {
    var _key = key
    var _value = value
    var originalHash = calcHashCode(key)
    var hash = originalHash
    var pos = hash
    var dis = 0
    var previous: OffheapOpt_${V_Arg} = OffheapOpt_${V_Arg}.empty
    while ({
      val nextHash = hashes(pos)
      if (isInit(nextHash)) {
        init(pos, hash, _key, _value)
        _size += 1
        growIfNecessary
        false
      } else if (nextHash == originalHash && hashK.eqv(_keys(pos), key)) {
        previous = OffheapOpt_${V_Arg}(_values(pos))
        _values(pos) = value
        false
      } else {
        val nextDis = (capacity + pos - nextHash) & mask
        if (nextDis < dis) {
          val nextKey = _keys(pos)
          val nextVal = _values(pos)
          hashes(pos) = hash
          _keys(pos) = _key
          _values(pos) = _value
          hash = nextHash
          _key = nextKey
          _value = nextVal
          dis = nextDis
        }
        dis += 1
        pos = (pos + 1) & mask
        true
      }
    }) ()
    previous
  }

  def remove(key: ${K_Arg})
      (implicit hashK: Hash_${K_Hash}, allocator: scala.offheap.Allocator): OffheapOpt_${V_Arg} = {
    var index = indexOf(key)
    if (index != -1) {
      val previous = OffheapOpt_${V_Arg}(_values(index))
      while ({
        val nextIndex = (index + 1) & mask
        val nextHash = hashes(nextIndex)
        if (!isInit(nextHash)) {
          val nextDis = (capacity + nextIndex - nextHash) & mask
          if (nextDis != 0) {
            hashes(index) = hashes(nextIndex)
            _keys(index) = _keys(nextIndex)
            _values(index) = _values(nextIndex)
            index = nextIndex
            true
          } else {
            false
          }
        } else {
          false
        }
      }) ()
      hashes(index) = 0
      _size -= 1
      previous
    } else {
      OffheapOpt_${V_Arg}.empty
    }
  }

  def keys(implicit hashK: Hash_${K_Hash}): HashSet_${K_Arg} = ???
//  {
//    val result = OffheapHashSet_${K_Arg}
//    var i = 0
//    while (i < capacity) {
//      if (!isInit(hashes(i))) result.add(_keys(i))
//      i += 1
//    }
//    result
//  }

  def values(implicit hashV: Hash_${V_Hash}, allocator: scala.offheap.Allocator): OffheapBufferSeq_${V_Arg} = {
    val result = OffheapSeq_${V_Arg}.create()
    var i = 0
    while (i < capacity) {
      if (!isInit(hashes(i))) result.append(_values(i))
      i += 1
    }
    result
  }

  def contains(key: ${K_Arg})(implicit hashK: Hash_${K_Hash}): Boolean = indexOf(key) != -1

  @inline
  private[this] def shouldGrow = _size > capacity * 9 / 10

  private[this] def growIfNecessary
      (implicit hashK: Hash_${K_Hash}, allocator: scala.offheap.Allocator): Unit = {
    if (shouldGrow) {
      val oldCapacity = capacity
      val oldHashes = hashes
      val oldKeys = _keys
      val oldValues = _values
      capacity *= 2
      mask = capacity - 1
      hashes = oh.Array.fill[Int](capacity) { 0 }
      _keys = oh.Array.uninit[${K_Arg}](capacity)
      _values = oh.Array.uninit[${V_Arg}](capacity)
      _size = 0
      var i = 0
      while (i < oldCapacity) {
        val hash = oldHashes(i)
        if (!isInit(hash)) {
          val key = oldKeys(i)
          val value = oldValues(i)
          put(key, value)
        }
        i += 1
      }
    }
  }

  private[this] def calcHashCode(key: ${K_Arg})(implicit hashK: Hash_${K_Hash}) = {
    var hash = hashK.hash(key) & mask
    hash |= (if (hash == 0) 1 else 0)
    hash
  }

  @inline
  private[this] def isInit(hash: Int) = hash == 0

  private[this] def init(pos: Int, hash: Int, key: ${K_Arg}, value: ${V_Arg}) = {
    hashes(pos) = hash
    _keys(pos) = key
    _values(pos) = value
  }

  def empty = _size == 0
  def notEmpty = _size != 0

  def size: Int = _size
  def foreach(f: (${K_Arg}, ${V_Arg}) => Unit): Unit = {
    var i = 0
    while (i < capacity) {
      val hash = hashes(i)
      if (!isInit(hash)) {
        val key = _keys(i)
        val value = _values(i)
        f(key, value)
      }
      i += 1
    }
  }
}

object OffheapMap_${K}_${V} {
  def create(initialSize: Int = 8)(implicit allocator: oh.Allocator): OffheapHashMap_${K}_${V} =
    OffheapHashMap_${K}_${V}(
      oh.Array.fill[Int](initialSize) { 0 }, // hashes
      oh.Array.uninit[${K_Arg}](initialSize), // keys
      oh.Array.uninit[${V_Arg}](initialSize), // values
      0, // size
      initialSize, // capacity
      initialSize - 1 // mask
    )
}

% end
% end
