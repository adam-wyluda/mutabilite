package offheap

import scala.language.experimental.{macros => CanMacro}

%{
types = ['Boolean', 'Char', 'Byte', 'Short',
'Int', 'Long', 'Float', 'Double']
}%

package object collection {

  % for T in types:

  implicit class SeqOps_${T}(val seq: Seq_${T}) extends AnyVal {
    def map[B](f: ${T} => B): Seq[B]          = macro offheap.collection.macros.SeqOpsMacros.map[${T}, B]
    def flatMap[B](f: ${T} => Seq[B]): Seq[B] = macro offheap.collection.macros.SeqOpsMacros.flatMap[${T}, B]
    def filter(f: ${T} => Boolean): Seq_${T}  = macro offheap.collection.macros.SeqOpsMacros.filter[${T}]
    def foreachMacro(f: ${T} => Unit): Unit   = macro offheap.collection.macros.SeqOpsMacros.foreach[${T}]
  }

  % end

  implicit class SeqOps_Object[A](val seq: Seq_Object[A]) extends AnyVal {
    def map[B](f: A => B): Seq[B]              = macro offheap.collection.macros.SeqOpsMacros.map[A, B]
    def flatMap[B](f: A => Seq[B]): Seq[B]     = macro offheap.collection.macros.SeqOpsMacros.flatMap[A, B]
    def filter(f: A => Boolean): Seq_Object[A] = macro offheap.collection.macros.SeqOpsMacros.filter[A]
    def foreachMacro(f: ${T} => Unit): Unit    = macro offheap.collection.macros.SeqOpsMacros.foreach[${T}]
  }
}
