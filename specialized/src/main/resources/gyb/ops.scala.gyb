package offheap.collection

import scala.language.experimental.{macros => CanMacro}

%{
from itertools import product

types = ['Boolean', 'Char', 'Byte', 'Short',
'Int', 'Long', 'Float', 'Double', 'Object']
}%

package object ops {

  % for T in types:
  %{
  if T == 'Object':
    T_Arg = 'T'
    T_Param = '[T]'
  else:
    T_Arg = T
    T_Param = ''
  }%

  implicit class SeqOps_${T}${T_Param}(val seq: Seq_${T}${T_Param}) extends AnyVal {
    def map[B](f: ${T_Arg} => B): Seq[B]                            = macro offheap.collection.macros.SeqOpsMacros.map[${T_Arg}, B]
    def flatMap[B](f: ${T_Arg} => Seq[B]): Seq[B]                   = macro offheap.collection.macros.SeqOpsMacros.flatMap[${T_Arg}, B]
    def filter(f: ${T_Arg} => Boolean): Seq_${T}${T_Param}          = macro offheap.collection.macros.SeqOpsMacros.filter[${T_Arg}]
    def foreachMacro(f: ${T_Arg} => Unit): Unit                     = macro offheap.collection.macros.SeqOpsMacros.foreach[${T_Arg}]
    def foldLeft[B](z: B)(op: (B, ${T_Arg}) => B): B                = macro offheap.collection.macros.SeqOpsMacros.foldLeft[${T_Arg}, B]
    def foldRight[B](z: B)(op: (${T_Arg}, B) => B): B               = macro offheap.collection.macros.SeqOpsMacros.foldRight[${T_Arg}, B]
    def reduceLeft(op: (${T_Arg}, ${T_Arg}) => ${T_Arg}): ${T_Arg}  = macro offheap.collection.macros.SeqOpsMacros.reduceLeft[${T_Arg}]
    def reduceRight(op: (${T_Arg}, ${T_Arg}) => ${T_Arg}): ${T_Arg} = macro offheap.collection.macros.SeqOpsMacros.reduceRight[${T_Arg}]
    def transform(f: ${T_Arg} => ${T_Arg}): Unit                    = macro offheap.collection.macros.SeqOpsMacros.transform[${T_Arg}]
    def forall(p: ${T_Arg} => Boolean): Boolean                     = macro offheap.collection.macros.SeqOpsMacros.forall[${T_Arg}]
    def exists(p: ${T_Arg} => Boolean): Boolean                     = macro offheap.collection.macros.SeqOpsMacros.exists[${T_Arg}]
    def sameElements(other: Seq_${T}${T_Param}): Boolean            = macro offheap.collection.macros.SeqOpsMacros.sameElements[${T_Arg}]
    def zipToMap[B](values: Seq[B]): Map[${T_Arg}, B]               = macro offheap.collection.macros.SeqOpsMacros.zipToMap[${T_Arg}, B]
  }

  implicit class SetOps_${T}${T_Param}(val set: Set_${T}${T_Param}) extends AnyVal {
    def map[B](f: ${T_Arg} => B): Set[B]                        = macro offheap.collection.macros.SetOpsMacros.map[${T_Arg}, B]
    def flatMap[B](f: ${T_Arg} => Set[B]): Set[B]               = macro offheap.collection.macros.SetOpsMacros.flatMap[${T_Arg}, B]
    def filter(f: ${T_Arg} => Boolean): Set_${T}${T_Param}      = macro offheap.collection.macros.SetOpsMacros.filter[${T_Arg}]
    def foreachMacro(f: ${T_Arg} => Unit): Unit                 = macro offheap.collection.macros.SetOpsMacros.foreach[${T_Arg}]
    def fold[B](z: B)(op: (B, ${T_Arg}) => B): B                = macro offheap.collection.macros.SetOpsMacros.fold[${T_Arg}, B]
    def reduce(op: (${T_Arg}, ${T_Arg}) => ${T_Arg}): ${T_Arg}  = macro offheap.collection.macros.SetOpsMacros.reduce[${T_Arg}]
    def forall(p: ${T_Arg} => Boolean): Boolean                 = macro offheap.collection.macros.SetOpsMacros.forall[${T_Arg}]
    def exists(p: ${T_Arg} => Boolean): Boolean                 = macro offheap.collection.macros.SetOpsMacros.exists[${T_Arg}]
  }

  % end

  % for (K, V) in product(types, types):
  %{
  if (K == 'Object' and V == 'Object'):
    Param = '[K, V]'
  elif K == 'Object':
    Param = '[K]'
  elif V == 'Object':
    Param = '[V]'
  else:
    Param = ''

  if K == 'Object':
    K_Arg = 'K'
  else:
    K_Arg = K

  if V == 'Object':
    V_Arg = 'V'
  else:
    V_Arg = V
  }%

  implicit class MapOps_${K}_${V}${Param}(val map: Map_${K}_${V}${Param}) extends AnyVal {
    def map[T](f: (${K_Arg}, ${V_Arg}) => T): Seq[T]                        = macro offheap.collection.macros.MapOpsMacros.map[${K_Arg}, ${V_Arg}, T]
    def mapKeys[T](f: ${K_Arg} => T): Map[T, ${V_Arg}]                      = macro offheap.collection.macros.MapOpsMacros.mapKeys[${K_Arg}, ${V_Arg}, T]
    def mapValues[T](f: ${V_Arg} => T): Map[${K_Arg}, T]                    = macro offheap.collection.macros.MapOpsMacros.mapValues[${K_Arg}, ${V_Arg}, T]
    def flatMap[T](f: (${K_Arg}, ${V_Arg}) => Seq[T]): Seq[T]               = macro offheap.collection.macros.MapOpsMacros.flatMap[${K_Arg}, ${V_Arg}, T]
    def filter(f: (${K_Arg}, ${V_Arg}) => Boolean): Map[${K_Arg}, ${V_Arg}] = macro offheap.collection.macros.MapOpsMacros.filter[${K_Arg}, ${V_Arg}]
    def foreachMacro(f: (${K_Arg}, ${V_Arg}) => Unit): Unit                 = macro offheap.collection.macros.MapOpsMacros.foreach[${K_Arg}, ${V_Arg}]
    def fold[B](z: B)(op: (B, ${K_Arg}, ${V_Arg}) => B): B                  = macro offheap.collection.macros.MapOpsMacros.fold[${K_Arg}, ${V_Arg}, B]
    def reduceKeys(op: (${K_Arg}, ${K_Arg}) => ${K_Arg}): ${K_Arg}          = macro offheap.collection.macros.MapOpsMacros.reduceKeys[${K_Arg}, ${V_Arg}]
    def reduceValues(op: (${V_Arg}, ${V_Arg}) => ${V_Arg}): ${V_Arg}        = macro offheap.collection.macros.MapOpsMacros.reduceValues[${K_Arg}, ${V_Arg}]
    def transformValues(f: ${V_Arg} => ${V_Arg}): Unit                      = macro offheap.collection.macros.MapOpsMacros.transformValues[${K_Arg}, ${V_Arg}]
    def forall(p: (${K_Arg}, ${V_Arg}) => Boolean): Boolean                 = macro offheap.collection.macros.MapOpsMacros.forall[${K_Arg}, ${V_Arg}]
    def exists(p: (${K_Arg}, ${V_Arg}) => Boolean): Boolean                 = macro offheap.collection.macros.MapOpsMacros.exists[${K_Arg}, ${V_Arg}]
  }

  % end
}
