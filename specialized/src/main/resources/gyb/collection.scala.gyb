package offheap

import scala.language.experimental.{macros => CanMacro}

%{
from itertools import product

types = ['Boolean', 'Char', 'Byte', 'Short',
'Int', 'Long', 'Float', 'Double', 'Object']
}%

package object collection {

  % for T in types:
  %{
  if T == 'Object':
    T_Arg = 'T'
    T_Param = '[T]'
  else:
    T_Arg = T
    T_Param = ''
  }%

  implicit class SeqOps_${T}${T_Param}(val seq: Seq_${T}${T_Param}) extends AnyVal {
    def map[B](f: ${T_Arg} => B): Seq[B]                   = macro offheap.collection.macros.SeqOpsMacros.map[${T_Arg}, B]
    def flatMap[B](f: ${T_Arg} => Seq[B]): Seq[B]          = macro offheap.collection.macros.SeqOpsMacros.flatMap[${T_Arg}, B]
    def filter(f: ${T_Arg} => Boolean): Seq_${T}${T_Param} = macro offheap.collection.macros.SeqOpsMacros.filter[${T_Arg}]
    def foreachMacro(f: ${T_Arg} => Unit): Unit            = macro offheap.collection.macros.SeqOpsMacros.foreach[${T_Arg}]
  }

  implicit class SetOps_${T}${T_Param}(val set: Set_${T}${T_Param}) extends AnyVal {
    def map[B](f: ${T_Arg} => B): Set[B]                   = macro offheap.collection.macros.SetOpsMacros.map[${T_Arg}, B]
    def flatMap[B](f: ${T_Arg} => Set[B]): Set[B]          = macro offheap.collection.macros.SetOpsMacros.flatMap[${T_Arg}, B]
    def filter(f: ${T_Arg} => Boolean): Set_${T}${T_Param} = macro offheap.collection.macros.SetOpsMacros.filter[${T_Arg}]
    def foreachMacro(f: ${T_Arg} => Unit): Unit            = macro offheap.collection.macros.SetOpsMacros.foreach[${T_Arg}]
  }

  % end

  % for (K, V) in product(types, types):
  %{
  if (K == 'Object' and V == 'Object'):
    Param = '[K, V]'
  elif K == 'Object':
    Param = '[K]'
  elif V == 'Object':
    Param = '[V]'
  else:
    Param = ''

  if K == 'Object':
    K_Arg = 'K'
  else:
    K_Arg = K

  if V == 'Object':
    V_Arg = 'V'
  else:
    V_Arg = V
  }%

  implicit class MapOps_${K}_${V}${Param}(val map: Map_${K}_${V}${Param}) extends AnyVal {
    def map[T](f: (${K_Arg}, ${V_Arg}) => T): Seq[T]     = macro offheap.collection.macros.MapOpsMacros.map[${K_Arg}, ${V_Arg}, T]
    def mapKeys[T](f: ${K_Arg} => T): Map[T, ${V_Arg}]   = macro offheap.collection.macros.MapOpsMacros.mapKeys[${K_Arg}, ${V_Arg}, T]
    def mapValues[T](f: ${V_Arg} => T): Map[${K_Arg}, T] = macro offheap.collection.macros.MapOpsMacros.mapValues[${K_Arg}, ${V_Arg}, T]
    def flatMap[T](f: (${K_Arg}, ${V_Arg}) => Seq[T]): Seq[T] = macro offheap.collection.macros.MapOpsMacros.flatMap[${K_Arg}, ${V_Arg}, T]
  }

  % end
}
