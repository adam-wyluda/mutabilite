package offheap

import scala.language.experimental.{macros => CanMacro}

%{
types = ['Boolean', 'Char', 'Byte', 'Short',
'Int', 'Long', 'Float', 'Double']
}%

package object collection {

  % for T in types:
  implicit class SeqOps_${T}(val seq: Seq_${T}) extends AnyVal {
    def map[B](f: ${T} => B): Seq[B]          = macro offheap.collection.macros.SeqOpsMacros.map[${T}, B]
    def flatMap[B](f: ${T} => Seq[B]): Seq[B] = macro offheap.collection.macros.SeqOpsMacros.flatMap[${T}, B]
    def filter(f: ${T} => Boolean): Seq_${T}  = macro offheap.collection.macros.SeqOpsMacros.filter[${T}]
    def foreachMacro(f: ${T} => Unit): Unit   = macro offheap.collection.macros.SeqOpsMacros.foreach[${T}]
  }
  % end

  implicit class SeqOps_Object[A](val seq: Seq_Object[A]) extends AnyVal {
    def map[B](f: A => B): Seq[B]              = macro offheap.collection.macros.SeqOpsMacros.map[A, B]
    def flatMap[B](f: A => Seq[B]): Seq[B]     = macro offheap.collection.macros.SeqOpsMacros.flatMap[A, B]
    def filter(f: A => Boolean): Seq_Object[A] = macro offheap.collection.macros.SeqOpsMacros.filter[A]
    def foreachMacro(f: ${T} => Unit): Unit    = macro offheap.collection.macros.SeqOpsMacros.foreach[${T}]
  }

  % for T in types:
  implicit class SetOps_${T}(val set: Set_${T}) extends AnyVal {
    def map[B](f: ${T} => B): Set[B]          = macro offheap.collection.macros.SetOpsMacros.map[${T}, B]
    def flatMap[B](f: ${T} => Set[B]): Set[B] = macro offheap.collection.macros.SetOpsMacros.flatMap[${T}, B]
    def filter(f: ${T} => Boolean): Set_${T}  = macro offheap.collection.macros.SetOpsMacros.filter[${T}]
    def foreachMacro(f: ${T} => Unit): Unit   = macro offheap.collection.macros.SetOpsMacros.foreach[${T}]
  }
  % end

  implicit class SetOps_Object[A](val set: Set_Object[A]) extends AnyVal {
    def map[B](f: A => B): Set[B]              = macro offheap.collection.macros.SetOpsMacros.map[A, B]
    def flatMap[B](f: A => Set[B]): Set[B]     = macro offheap.collection.macros.SetOpsMacros.flatMap[A, B]
    def filter(f: A => Boolean): Set_Object[A] = macro offheap.collection.macros.SetOpsMacros.filter[A]
    def foreachMacro(f: A => Unit): Unit       = macro offheap.collection.macros.SetOpsMacros.foreach[A]
  }

  % for K in types:
  % for V in types:
  implicit class MapOps_${K}_${V}(val map: Map_${K}_${V}) extends AnyVal {
    def map[T](f: (${K}, ${V}) => T): Seq[T] = macro offheap.collection.macros.MapOpsMacros.map[${K}, ${V}, T]
  }
  % end
  % end

  % for K in types:
  implicit class MapOps_${K}_Object[V](val map: Map_${K}_Object[V]) extends AnyVal {
    def map[T](f: (${K}, V) => T): Seq[T] = macro offheap.collection.macros.MapOpsMacros.map[${K}, V, T]
  }
  % end

  % for V in types:
  implicit class MapOps_Object_${V}[K](val map: Map_Object_${V}[K]) extends AnyVal {
    def map[T](f: (K, ${V}) => T): Seq[T] = macro offheap.collection.macros.MapOpsMacros.map[K, ${V}, T]
  }
  % end

  implicit class MapOps_Object_Object[K, V](val map: Map_Object_Object[K, V]) extends AnyVal {
    def map[T](f: (K, V) => T): Seq[T] = macro offheap.collection.macros.MapOpsMacros.map[K, V, T]
  }
}
